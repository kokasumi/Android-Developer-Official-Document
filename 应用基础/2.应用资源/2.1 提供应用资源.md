## 2.1 提供应用资源

> 原文内容可参考[Providing Resources](https://developer.android.com/guide/topics/resources/providing-resources.html)

在开发过程中，应该始终保持应用资源与代码分离，以便能够独立维护。为了能够适配特殊配置的设备型号，还应该为其提供替换资源，将其放到特殊设备对应的资源目录中；在Android运行时，系统能够根据当前设备的配置信息加载合适的资源。

### 分组资源类型

Android开发中的所有资源文件都放到项目`res/`的子目录中，不能直接放到`res/`文件夹下，否则会导致编译时异常。为了方便维护，需要根据资源文件的类型将其放置到不同的资源目录中，Android系统默认支持以下资源目录：

- `animator/` 定义[属性动画](https://developer.android.com/guide/topics/graphics/prop-animation.html)的XML文件。
- `anim/` 定义[补间动画](https://developer.android.com/guide/topics/graphics/view-animation.html#tween-animation)的XML文件。属性动画也可以放到该目录下，但是为了区分这两种动画类型，将属性动画放到`animator/`目录下是最合适的。
- `color/` 定义[Color State List资源](https://developer.android.com/guide/topics/resources/color-list-resource.html)的XML文件。
- `drawable/` 放置Bitmap文件(`.png`, `.9.png`, `.jpg`, `.gif`)或者能够编译为Drawable资源的XML文件，详情可见[Drawable Resources](https://developer.android.com/guide/topics/resources/drawable-resource.html)。
- `mipmap/` 放置不同密度启动图标对应的Drawable文件。
- `layout/` 定义用户界面布局的XML文件。
- `menu/` 定义用户菜单的XML文件。
- `raw/` 以原始格式保存的任意文件。使用[Resources.openRawResource()](https://developer.android.com/reference/android/content/res/Resources.html#openRawResource(int))并传入资源文件ID(`R.raw.filename`)打开相应文件资源[InputStream](https://developer.android.com/reference/java/io/InputStream.html)；如果想要使用原始文件名和文件层次结构访问文件资源，可以将文件放到`assets/`目录中，在`assets/`目录中的文件不会生成资源ID。
- `values/` 定义简单值的XML文件。与其他`res/`子目录不同的是，其他子目录一个XML文件只定义一个单独的资源，但`values/`目录下一个XML文件中可以定义多个资源。其中每一个`<resources>`元素中的每一个子元素定义的都是一个单独的资源，比如`<string>`定义了一个`R.string`资源，`<color>`定义了一个`R.color`资源。该目录下的文件对于资源类型不会有区分，可以将不同类型的资源放到同一个文件中，但为了代码的可维护性，推荐将不同类型的资源放到不同的文件中。其中常见的文件有以下几种：
  - `arrays.xml` 用于定义资源数组
  - `colors.xml` 用于定义颜色
  - `dimens.xml` 用于定义尺寸
  - `strings.xml` 用于定义字符
  - `styles.xml` 用于定义样式
- `xml/` 放置任意的XML文件，可以在运行时调用[Resources.getXML()](https://developer.android.com/reference/android/content/res/Resources.html#getXml(int))读取相关XML文件。各种XML配置文件必须保存在该文件夹下。
- `font/` 放置以`.ttf`, `.otf`, 或者 `.ttc`为后缀名的字体文件，或者包含`<font-family>`元素的XML文件。

### 提供替代资源

使用上面的资源文件夹提供资源只能为设备提供默认资源，但目前市面上的手机千差万别，不同分辨率，不同语言环境，为了对这些手机进行适配，就必须对不同配置的机型提供替代资源。在Android运行时，系统会根据当前设备配置加载合适的资源。一般我们都使用限定符来提供替代资源，在资源文件后加上限定符并使用短横线分隔开，如`drawable-hdpi`，并将替代资源放到限定符文件中。

#### 资源限定符分类

1. **MCC和MNC** 根据设备的SIM卡提供的移动设备国家代码(MCC)以及可选的移动设备网络代码(MNC)来过滤，通俗的讲就是根据SIM卡的网络运营商来过滤。如`mcc460`表示中国境内的SIM卡，`mcc460-mnc00`就表示中国移动。可以单独使用MCC进行过滤，如提供某个国家特殊的法律文件资源，如果只需要根据语言进行限定，可以使用*语言和区域*限定符进行指定。具体的MCC和MNC相关信息可可见[Mobile country code](https://en.wikipedia.org/wiki/Mobile_country_code)。

2. **语言和地区** 语言使用两个字符的[ISO 639-1](http://www.loc.gov/standards/iso639-2/php/code_list.php)语言code码表示，其后可以跟两个字符的[ISO 3166-1-alpha-2](https://www.iso.org/obp/ui/#iso:pub:PUB500001:en)可选地区code码，code码不区分大小写，如果跟上地区code码，前面必须跟上小写字母`r`，用于区分地区部分，如`en-rUS`表示美式英语，而`en-rGB`表示英式英语。

   Android 7.0(API 24)支持了[BCP 47 language tags](https://tools.ietf.org/html/bcp47)，可以用其限定语言和地区特定的资源。使用BCP 47语言标签，需要连接`b+`和两个字符的[ISO 639-1](http://www.loc.gov/standards/iso639-2/php/code_list.php)语言code码，其后可跟上使用`+` 分割的地区子标签。如`b+en`表示英语，`b+en+US`表示美式英语。

3. **布局方向** 应用的布局方向。`ldrtl`是"layout-direction-right-to-left"的缩写，表示布局方向从右到左；`ldltr`是"layout-direction-left-to-right"，表示布局方向从左到右，是默认的布局方式。该限定符可以应用于所有的资源文件，为了支持`ldrtl`布局，必须设置[`supportsRtl`](https://developer.android.google.cn/guide/topics/manifest/application-element.html#supportsrtl)属性为`true`并且[`targetSdkVersion`](https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element.html#target)为17及以上。

4. **最小宽度** 一般使用`sw<N>dp`表示，如`sw320dp`。**最小宽度为屏幕可用高度和宽度中最小的，最与屏幕方向无关，无论屏幕方向怎么样，屏幕的可用宽度最小为`<N>`dp。**最小宽度需要考虑屏幕上的装饰以及系统UI，因为这些会限制屏幕的最小宽度。应用提供多种最小宽度限定符时，系统会选择最接近的一个宽度限定符资源。使用[`android:requiresSmallestWidthDp`](https://developer.android.google.cn/guide/topics/manifest/supports-screens-element.html#requiresSmallest)属性声明应用适配的最小屏幕宽度，可以使用[smallestScreenWidthDp](https://developer.android.google.cn/reference/android/content/res/Configuration.html#smallestScreenWidthDp)获取当前屏幕的最小宽度。

5. **可用宽度** 使用`w<N>dp`表示，如`w720dp`。**与最小宽度不一样，可用宽度是指屏幕上水平方向的可用屏幕长度，会随着屏幕方向的旋转而改变。**可用宽度需要考虑到屏幕水平方向上的装饰以及系统UI，这些会限制屏幕的可用宽度。使用[screenWidthDp](https://developer.android.google.cn/reference/android/content/res/Configuration.html#screenWidthDp)可以获取当前屏幕的可用宽度。

6. **可用高度** 使用`h<N>dp`表示，如`h720dp`。**与可用宽度类似，可用高度是指屏幕垂直方向的可用屏幕长度，会随着屏幕方向的旋转而改变。**因为垂直方向的UI通常都是可滚动的，因此一般不需要考虑可用高度。可以使用[screenHeightDp](https://developer.android.google.cn/reference/android/content/res/Configuration.html#screenHeightDp)获取当前屏幕的可用高度。

7. **屏幕尺寸** 

   - `small` 类似于低密度QVGA屏幕尺寸，small屏幕的最小布局尺寸为320x426 dp。
   - `normal` 类似于中密度HVGA屏幕尺寸，normal屏幕的最小布局尺寸为320x470 dp。
   - `large` 类似于中密度VGA屏幕尺寸，large屏幕的最小布局尺寸为480x640 dp。
   - `xlarge` 比传统的中密度HVGA屏幕更大的尺寸，xlarge屏幕的最小布局尺寸为720x960 dp。

8. **屏幕方面** 有`long`和`notlong`两种，完全基于屏幕的长宽比，与屏幕方向无关。可以使用[screenLayout](https://developer.android.google.cn/reference/android/content/res/Configuration.html#screenLayout)获取屏幕是`long`或者`nolong`类型。

9. **屏幕形状** 有`round`(圆形屏幕)和`notround`(方形屏幕)两种。可以使用[isScreenRound()](https://developer.android.google.cn/reference/android/content/res/Configuration.html#isScreenRound())获取屏幕是否是圆形。

10. **WCG(Wide Color Gamut，宽色域)** 有`widecg`和`nowidecg`，一般是用于适配电视屏幕的。`widecg`能够显示广泛的色域，如P3或者AdobeRGB；`nowidecg0`显示比较窄的色域，如sRGB。可以使用[isScreenWideColorGamut()](https://developer.android.google.cn/reference/android/content/res/Configuration.html#isScreenWideColorGamut())获取屏幕是否支持WCG。关于WCG的详细内容可查看[What is wide color gamut (WCG)?](https://www.cnet.com/how-to/what-is-wide-color-gamut-wcg/)

11. **HDR(High Dynamic Range，高动态范围成像)** 有`highdr`和`lowdr`两种，一般用于适配电视屏幕。`highdr`能够使用高动态范围成像显示，`lowdr`使用低/标准动态范围成像显示。可以使用[isScreenHdr()](https://developer.android.google.cn/reference/android/content/res/Configuration.html#isScreenHdr())获取屏幕是否支持HDR。关于HDR更详细的内容可查看[How HDR works](https://www.cnet.com/news/how-hdr-works/)

12. **屏幕方向** 包含`port`(设备位于垂直方向)和`land`(设备位于水平方向)两种。可以使用[orientation](https://developer.android.google.cn/reference/android/content/res/Configuration.html#orientation)获取当前屏幕的方向。

13. **UI模式** 

    - `car` 车载系统模式。
    - `desk` DeskDock模式。
    - `television` 电视屏幕模式。
    - `appliance` 作为appliance模式，不提供用户界面。
    - `watch` 智能手表模式。
    - `vrheadset` 虚拟现实设备模式。

14. **夜间模式** 有`night`(夜间模式)和`notnight`(白天模式)两种模式。

15. **DPI(Screen pixel density，屏幕像素密度)** 

    - `ldpi` 低密度屏幕，大约为120dpi。
    - `mdpi` 中密度屏幕，大约为160dpi。
    - `hdpi` 高密度屏幕，大约为240dpi。
    - `xhdpi` 超高密度屏幕，大约为320dpi。
    - `xxhdpi` 超高密度屏幕，大约为480dpi。
    - `xxxhdpi` 额外超高密度屏幕，大约为640dpi。
    - `nodpi` 可用于不想缩放以匹配屏幕像素密度的图片。
    - `tvdpi` 介于`mdpi`和`hdpi`之间，大约为213dpi，主要用于电视应用。
    - `anydpi` 匹配所有密度屏幕并且优先级高于其他像素限定符。
    - `nnndpi` 用于非标准密度屏幕，大多数情况不需要使用。

16. **触摸屏类型** 有`notouch`(不支持触摸屏)和`finger`(通过用户手指方向来使用的触摸屏)两种。

17. **键盘可用性** 

    - `keysexposed` 设备有可用键盘。
    - `keyshidden` 设备有可用的硬件键盘，但是硬件键盘是隐藏的，并且设备没有启用软件键盘。
    - `keyssoft` 设备启用了软件键盘，无论其是否可见。

18. **主要文字输入方式** 

    - `nokeys` 设备没有用于文本输入的硬件键。
    - `qwerty` 设备有硬件qwerty键盘，无论对用户是否可见。
    - `12key` 设备有硬件12-key键盘，无论对用户是否可见。

19. **导航键可用性** `navexposed`表示导航键对用户可用；`navhidden`导航键对用户不可用。

20. **主要的非触摸导航方式** 

    - `nonav` 除了触摸屏之外，没有其他导航方式。
    - `dpad` 设备有一个方向键盘用于导航。
    - `trackball` 设备有用于导航的轨迹球。
    - `wheel` 设备有用于导航的定向轮。

21. **平台版本** 设备支持的API级别。

#### 限定符名称规则

- 一个资源文件夹名称可以有多个限定符，使用短横线分隔开。比如`drawable-en-rUS-land`应用于美式英语环境的横向设备。
- 限定符必须按照上面的限定符资源分类顺序排列。
- 替代资源目录不能嵌套，如`res/drawable/drawable-en/`是错误的。
- 限定符不区分大小写，资源编译器会在处理之前将目录全部转换为小写以避免大小写冲突问题。
- 每个备用资源目录中同类限定只能出现一种，如`drawable-rES-rFR/`是一种错误的写法。

#### 创建别名资源

在提供备用资源时，可能会存在这样一种场景，在多个备用目录中会使用到同一个资源文件，比如说我们的应用需要在不同的语言版本中展示不同的图标`icon.png`，但是其中` English-Canadian`和`French-Canadian`两种语言需要使用相同版本的icon。这样就有以下几种做法可以达到目录：

1. 在两个目录下分别放入相同的`icon.png`。但是这样的话存在一个很明显的问题，如果有3，4，5，6...个语言版本需要相同的icon，每个目录中都放入相同icon，这样就非常浪费资源；并且如果图标一旦有变动的话，就会对每个目录都进行替换，这样一来就很不容易维护。
2. 将需要使用的相同`icon.png`放入`drawable`目录作为默认图标，相同版本图标备用资源目录`icon.png`缺省，这样一来也就解决了浪费资源和不易维护的问题。但是这一种方法也存在着一个致命的缺陷，如果除了` English-Canadian`和`French-Canadian`之外，还有`English-US`和`English-UK`也使用另一个相同`icon.png`，这样就没办法在`drawable`文件夹下放2个默认图标。
3. Android系统提供了一种别名资源的方式可以解决这个问题。将相同的图片资源放到`drawable`目录下，将其命名为除`icon.png`之外的名字，然后在每个单独的备用资源目录下创建别名资源。

##### Drawable

可以使用`<drawable>`元素创建别名Drawable图像。

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <drawable name="icon">@drawable/icon_ca</drawable>
</resources>
```

##### Layout

使用`<include>`元素来为存在的布局文件创建别名，需要使用`<merge>`标签进行包装。如果将其保存为`main.xml`，可以使用`R.layout.main`进行引用。		

```xml
<?xml version="1.0" encoding="utf-8"?>
<merge>
    <include layout="@layout/main_ltr"/>
</merge>
```

##### String及其他简单值

要为现有字符串创建别名，需要使用现有字符串的资源ID引用作为新字符串的值。

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello">Hello</string>
    <string name="hi">@string/hello</string>
</resources>
```

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="red">#f00</color>
    <color name="highlight">@color/red</color>
</resources>
```

